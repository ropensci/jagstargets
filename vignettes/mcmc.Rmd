---
title: "MCMC pipelines"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{MCMC pipelines}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_knit$set(root.dir = fs::dir_create(tempfile()))
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
if (identical(Sys.getenv("NOT_CRAN", unset = "false"), "false")) {
  knitr::opts_chunk$set(eval = FALSE)
}
library(R2jags)
library(dplyr)
library(targets)
library(jagstargets)
```

The `jagstargets` package makes it easy to run a single jags model and keep track of the results. [`R2jags`](https://github.com/suyusung/R2jags) fits the models, and [`targets`](https://github.com/wlandau/targets) manages the workflow and helps avoid unnecessary computation.

First, write a jags model file.

```{r}
lines <- "model {
  for (i in 1:n) {
    y[i] ~ dnorm(x[i] * beta, 1)
  }
  beta ~ dnorm(0, 1)
}"
writeLines(lines, "x.jags")
```


Next, create a `_targets.R` file to define the [`targets`](https://github.com/wlandau/targets) pipeline.

```{r, echo = FALSE}
library(targets)
tar_script({
  library(jagstargets)
  options(crayon.enabled = FALSE)
  list(
    tar_jags(
      example,
      jags_files = "x.jags",
      parameters.to.save = "beta",
      data = tar_jags_example_data(true_params = FALSE),
      log = R.utils::nullfile()
    )
  )
})
```

```{r, eval = FALSE}
# _targets.R
library(targets)
library(jagstargets)
list(
  tar_jags(
    example,
    jags_files = "x.jags",
    parameters.to.save = "beta",
    data = tar_jags_example_data(true_params = FALSE),
    log = R.utils::nullfile()
  )
)
```


`tar_jags(example, ...)` defines several targets:

* `example_file_x`: Reproducibly track changes to the jags model file.
* `example_data`: Run the code you supplied to `data` and return a dataset compatible with jags.
* `example_mcmc_x`: Run the MCMC and return an object of class `rjags` from [`R2jags`](https://github.com/suyusung/R2jags).
* `example_draws_x`: Return a friendly `tibble` of the posterior draws from `example`.
* `example_summaries_x`: Return a friendly `tibble` of the posterior summaries from `example`. Uses [`posterior::summarize_draws()`](https://mc-stan.org/posterior/reference/draws_summary.html)
* `example_dic_x`: Return a friendly `tibble` with each model's DIC and penalty.

The suffix `_x` comes from the base name of the model file, in this case `x.jags`. If you supply multiple model files to the `jags_files` argument, all the models share the same dataset, and the suffixes distinguish among the various targets.

Run `tar_manifest()` to see a tidy data frame of commands and settings for the targets.

```{r}
tar_manifest()
```

[`targets`](https://github.com/wlandau/targets) produces a graph to show the dependency relationships among the targets. Below, the MCMC depends on the model file and the data, and the draws, summary, and diagnostics depend on the MCMC.

```{r, output = FALSE, message = FALSE}
tar_visnetwork(targets_only = TRUE)
```

Run the computation with `tar_make()`.

```{r, output = FALSE}
tar_make()
```

The output lives in a special folder called `_targets/` and you can retrieve it with functions `tar_load()` and `tar_read()` (from [`targets`](https://github.com/wlandau/targets)).

```{r}
tar_read(example_summary_x)
```

At this point, all our results are up to date because their dependencies did not change.

```{r}
tar_make()
```

But if we change the underlying code or data, some of the targets will no longer be valid, and they will rerun during the next `tar_make()`. Below, we change the jags model file, so the MCMC reruns while the data is skipped. This behavior saves time and enhances reproducibility.

```{r}
write(" ", file = "x.jags", append = TRUE)
```

```{r}
tar_outdated()
```

```{r}
tar_visnetwork(targets_only = TRUE)
```

```{r, output = FALSE}
tar_make()
```

At this point, we can add more targets and custom functions for additional post-processing. See below for a custom summary target (which is equivalent to customizing the `summaries` argument of `tar_jags()`.)

```{r, echo = FALSE}
tar_script({
  library(jagstargets)
  options(crayon.enabled = FALSE)
  tar_option_set(memory = "transient", garbage_collection = TRUE)
  list(
    tar_jags(
      example,
      jags_files = "x.jags",
      parameters.to.save = "beta",
      data = tar_jags_example_data(true_params = FALSE),
      log = R.utils::nullfile()
    ),
    tar_target(
      custom_summary,
      posterior::summarize_draws(
        dplyr::select(example_draws_x, -.draw),
        ~posterior::quantile2(.x, probs = c(0.25, 0.75))
      )
    )
  )
})
```

```{r, eval = FALSE}
# _targets.R
library(targets)
library(jagstargets)
list(
  tar_jags(
    example,
    jags_files = "x.jags",
    parameters.to.save = "beta",
    data = tar_jags_example_data(true_params = FALSE),
    log = R.utils::nullfile()
  ),
  tar_target(
    custom_summary,
    posterior::summarize_draws(
      dplyr::select(example_draws_x, -.draw),
      ~posterior::quantile2(.x, probs = c(0.25, 0.75))
    )
  )
)
```

In the graph, our new `custom_summary` target should be connected to the upstream `example` target, and only `custom_summary` should be out of date.

```{r}
tar_visnetwork(targets_only = TRUE)
```

In the next `tar_make()`, we skip the expensive MCMC and just run the custom summary.

```{r, output = FALSE, warning = FALSE}
tar_make()
```

```{r}
tar_read(custom_summary)
```

## Multiple models

`tar_jags()` and related functions allow you to supply multiple models to `jags_files`. If you do, each model will run on the same dataset. Below, we add another `y.jags` model to the `jags_files` argument of `tar_jags()`.

```{r, echo = FALSE}
tar_script({
  library(targets)
  library(jagstargets)
  list(
    tar_jags(
      example,
      jags_files = c("x.jags", "y.jags"),
      parameters.to.save = "beta",
      data = tar_jags_example_data(true_params = FALSE),
      log = R.utils::nullfile()
    ),
    tar_target(
      custom_summary,
      posterior::summarize_draws(
        dplyr::select(example_draws_x, -.draw),
        ~posterior::quantile2(.x, probs = c(0.25, 0.75))
      )
    )
  )
})
```

```{r, eval = FALSE}
# _targets.R
library(targets)
library(jagstargets)
list(
  tar_jags(
    example,
    jags_files = c("x.jags", "y.jags"),
    parameters.to.save = "beta",
    data = tar_jags_example_data(true_params = FALSE),
    log = R.utils::nullfile()
  ),
  tar_target(
    custom_summary,
    posterior::summarize_draws(
      dplyr::select(example_draws_x, -.draw),
      ~posterior::quantile2(.x, probs = c(0.25, 0.75))
    )
  )
)
```

In the graph below, notice how the `*_x` targets and `*_y` targets are both connected to `example_data` upstream.

```{r}
tar_visnetwork(targets_only = TRUE)
```

## More information

For more on [`targets`](https://github.com/wlandau/targets), please visit the reference website <https://wlandau.github.io/targets/> or the user manual <https://wlandau.github.io/targets-manual/>. The manual walks though advanced features of `targets` such as [high-performance computing](https://wlandau.github.io/targets-manual/hpc.html) and [cloud storage support](https://wlandau.github.io/targets-manual/cloud.html).
